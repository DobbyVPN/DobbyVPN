// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.1
// source: vpnserver.proto

package vpnserver

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Vpn_StartAwg_FullMethodName            = "/vpnserver.Vpn/StartAwg"
	Vpn_StopAwg_FullMethodName             = "/vpnserver.Vpn/StopAwg"
	Vpn_GetOutlineLastError_FullMethodName = "/vpnserver.Vpn/GetOutlineLastError"
	Vpn_StartOutline_FullMethodName        = "/vpnserver.Vpn/StartOutline"
	Vpn_StopOutline_FullMethodName         = "/vpnserver.Vpn/StopOutline"
	Vpn_StartHealthCheck_FullMethodName    = "/vpnserver.Vpn/StartHealthCheck"
	Vpn_StopHealthCheck_FullMethodName     = "/vpnserver.Vpn/StopHealthCheck"
	Vpn_Status_FullMethodName              = "/vpnserver.Vpn/Status"
	Vpn_TcpPing_FullMethodName             = "/vpnserver.Vpn/TcpPing"
	Vpn_UrlTest_FullMethodName             = "/vpnserver.Vpn/UrlTest"
	Vpn_CouldStart_FullMethodName          = "/vpnserver.Vpn/CouldStart"
	Vpn_CheckServerAlive_FullMethodName    = "/vpnserver.Vpn/CheckServerAlive"
	Vpn_StartCloakClient_FullMethodName    = "/vpnserver.Vpn/StartCloakClient"
	Vpn_StopCloakClient_FullMethodName     = "/vpnserver.Vpn/StopCloakClient"
	Vpn_InitLogger_FullMethodName          = "/vpnserver.Vpn/InitLogger"
)

// VpnClient is the client API for Vpn service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VpnClient interface {
	// awg.go
	StartAwg(ctx context.Context, in *StartAwgRequest, opts ...grpc.CallOption) (*Empty, error)
	StopAwg(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// outline.go
	GetOutlineLastError(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetOutlineLastErrorResponse, error)
	StartOutline(ctx context.Context, in *StartOutlineRequest, opts ...grpc.CallOption) (*StartOutlineResponse, error)
	StopOutline(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// health_check.go
	StartHealthCheck(ctx context.Context, in *StartHealthCheckRequest, opts ...grpc.CallOption) (*Empty, error)
	StopHealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponce, error)
	TcpPing(ctx context.Context, in *TcpPingRequest, opts ...grpc.CallOption) (*TcpPingResponce, error)
	UrlTest(ctx context.Context, in *UrlTestRequest, opts ...grpc.CallOption) (*UrlTestResponce, error)
	CouldStart(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CouldStartResponce, error)
	CheckServerAlive(ctx context.Context, in *CheckServerAliveRequest, opts ...grpc.CallOption) (*CheckServerAliveResponce, error)
	// cloak.go
	StartCloakClient(ctx context.Context, in *StartCloakClientRequest, opts ...grpc.CallOption) (*Empty, error)
	StopCloakClient(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// logger.go
	InitLogger(ctx context.Context, in *InitLoggerRequest, opts ...grpc.CallOption) (*Empty, error)
}

type vpnClient struct {
	cc grpc.ClientConnInterface
}

func NewVpnClient(cc grpc.ClientConnInterface) VpnClient {
	return &vpnClient{cc}
}

func (c *vpnClient) StartAwg(ctx context.Context, in *StartAwgRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_StartAwg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) StopAwg(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_StopAwg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) GetOutlineLastError(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetOutlineLastErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOutlineLastErrorResponse)
	err := c.cc.Invoke(ctx, Vpn_GetOutlineLastError_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) StartOutline(ctx context.Context, in *StartOutlineRequest, opts ...grpc.CallOption) (*StartOutlineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartOutlineResponse)
	err := c.cc.Invoke(ctx, Vpn_StartOutline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) StopOutline(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_StopOutline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) StartHealthCheck(ctx context.Context, in *StartHealthCheckRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_StartHealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) StopHealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_StopHealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponce, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponce)
	err := c.cc.Invoke(ctx, Vpn_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) TcpPing(ctx context.Context, in *TcpPingRequest, opts ...grpc.CallOption) (*TcpPingResponce, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TcpPingResponce)
	err := c.cc.Invoke(ctx, Vpn_TcpPing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) UrlTest(ctx context.Context, in *UrlTestRequest, opts ...grpc.CallOption) (*UrlTestResponce, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UrlTestResponce)
	err := c.cc.Invoke(ctx, Vpn_UrlTest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) CouldStart(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CouldStartResponce, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CouldStartResponce)
	err := c.cc.Invoke(ctx, Vpn_CouldStart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) CheckServerAlive(ctx context.Context, in *CheckServerAliveRequest, opts ...grpc.CallOption) (*CheckServerAliveResponce, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckServerAliveResponce)
	err := c.cc.Invoke(ctx, Vpn_CheckServerAlive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) StartCloakClient(ctx context.Context, in *StartCloakClientRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_StartCloakClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) StopCloakClient(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_StopCloakClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnClient) InitLogger(ctx context.Context, in *InitLoggerRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Vpn_InitLogger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VpnServer is the server API for Vpn service.
// All implementations must embed UnimplementedVpnServer
// for forward compatibility.
type VpnServer interface {
	// awg.go
	StartAwg(context.Context, *StartAwgRequest) (*Empty, error)
	StopAwg(context.Context, *Empty) (*Empty, error)
	// outline.go
	GetOutlineLastError(context.Context, *Empty) (*GetOutlineLastErrorResponse, error)
	StartOutline(context.Context, *StartOutlineRequest) (*StartOutlineResponse, error)
	StopOutline(context.Context, *Empty) (*Empty, error)
	// health_check.go
	StartHealthCheck(context.Context, *StartHealthCheckRequest) (*Empty, error)
	StopHealthCheck(context.Context, *Empty) (*Empty, error)
	Status(context.Context, *Empty) (*StatusResponce, error)
	TcpPing(context.Context, *TcpPingRequest) (*TcpPingResponce, error)
	UrlTest(context.Context, *UrlTestRequest) (*UrlTestResponce, error)
	CouldStart(context.Context, *Empty) (*CouldStartResponce, error)
	CheckServerAlive(context.Context, *CheckServerAliveRequest) (*CheckServerAliveResponce, error)
	// cloak.go
	StartCloakClient(context.Context, *StartCloakClientRequest) (*Empty, error)
	StopCloakClient(context.Context, *Empty) (*Empty, error)
	// logger.go
	InitLogger(context.Context, *InitLoggerRequest) (*Empty, error)
	mustEmbedUnimplementedVpnServer()
}

// UnimplementedVpnServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVpnServer struct{}

func (UnimplementedVpnServer) StartAwg(context.Context, *StartAwgRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAwg not implemented")
}
func (UnimplementedVpnServer) StopAwg(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAwg not implemented")
}
func (UnimplementedVpnServer) GetOutlineLastError(context.Context, *Empty) (*GetOutlineLastErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutlineLastError not implemented")
}
func (UnimplementedVpnServer) StartOutline(context.Context, *StartOutlineRequest) (*StartOutlineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartOutline not implemented")
}
func (UnimplementedVpnServer) StopOutline(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopOutline not implemented")
}
func (UnimplementedVpnServer) StartHealthCheck(context.Context, *StartHealthCheckRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartHealthCheck not implemented")
}
func (UnimplementedVpnServer) StopHealthCheck(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopHealthCheck not implemented")
}
func (UnimplementedVpnServer) Status(context.Context, *Empty) (*StatusResponce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedVpnServer) TcpPing(context.Context, *TcpPingRequest) (*TcpPingResponce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TcpPing not implemented")
}
func (UnimplementedVpnServer) UrlTest(context.Context, *UrlTestRequest) (*UrlTestResponce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UrlTest not implemented")
}
func (UnimplementedVpnServer) CouldStart(context.Context, *Empty) (*CouldStartResponce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CouldStart not implemented")
}
func (UnimplementedVpnServer) CheckServerAlive(context.Context, *CheckServerAliveRequest) (*CheckServerAliveResponce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckServerAlive not implemented")
}
func (UnimplementedVpnServer) StartCloakClient(context.Context, *StartCloakClientRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCloakClient not implemented")
}
func (UnimplementedVpnServer) StopCloakClient(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopCloakClient not implemented")
}
func (UnimplementedVpnServer) InitLogger(context.Context, *InitLoggerRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitLogger not implemented")
}
func (UnimplementedVpnServer) mustEmbedUnimplementedVpnServer() {}
func (UnimplementedVpnServer) testEmbeddedByValue()             {}

// UnsafeVpnServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VpnServer will
// result in compilation errors.
type UnsafeVpnServer interface {
	mustEmbedUnimplementedVpnServer()
}

func RegisterVpnServer(s grpc.ServiceRegistrar, srv VpnServer) {
	// If the following call pancis, it indicates UnimplementedVpnServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Vpn_ServiceDesc, srv)
}

func _Vpn_StartAwg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAwgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StartAwg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StartAwg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StartAwg(ctx, req.(*StartAwgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_StopAwg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StopAwg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StopAwg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StopAwg(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_GetOutlineLastError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).GetOutlineLastError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_GetOutlineLastError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).GetOutlineLastError(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_StartOutline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartOutlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StartOutline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StartOutline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StartOutline(ctx, req.(*StartOutlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_StopOutline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StopOutline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StopOutline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StopOutline(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_StartHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StartHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StartHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StartHealthCheck(ctx, req.(*StartHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_StopHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StopHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StopHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StopHealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).Status(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_TcpPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).TcpPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_TcpPing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).TcpPing(ctx, req.(*TcpPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_UrlTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UrlTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).UrlTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_UrlTest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).UrlTest(ctx, req.(*UrlTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_CouldStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).CouldStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_CouldStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).CouldStart(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_CheckServerAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckServerAliveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).CheckServerAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_CheckServerAlive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).CheckServerAlive(ctx, req.(*CheckServerAliveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_StartCloakClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCloakClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StartCloakClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StartCloakClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StartCloakClient(ctx, req.(*StartCloakClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_StopCloakClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).StopCloakClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_StopCloakClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).StopCloakClient(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vpn_InitLogger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitLoggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServer).InitLogger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Vpn_InitLogger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServer).InitLogger(ctx, req.(*InitLoggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Vpn_ServiceDesc is the grpc.ServiceDesc for Vpn service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vpn_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vpnserver.Vpn",
	HandlerType: (*VpnServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartAwg",
			Handler:    _Vpn_StartAwg_Handler,
		},
		{
			MethodName: "StopAwg",
			Handler:    _Vpn_StopAwg_Handler,
		},
		{
			MethodName: "GetOutlineLastError",
			Handler:    _Vpn_GetOutlineLastError_Handler,
		},
		{
			MethodName: "StartOutline",
			Handler:    _Vpn_StartOutline_Handler,
		},
		{
			MethodName: "StopOutline",
			Handler:    _Vpn_StopOutline_Handler,
		},
		{
			MethodName: "StartHealthCheck",
			Handler:    _Vpn_StartHealthCheck_Handler,
		},
		{
			MethodName: "StopHealthCheck",
			Handler:    _Vpn_StopHealthCheck_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Vpn_Status_Handler,
		},
		{
			MethodName: "TcpPing",
			Handler:    _Vpn_TcpPing_Handler,
		},
		{
			MethodName: "UrlTest",
			Handler:    _Vpn_UrlTest_Handler,
		},
		{
			MethodName: "CouldStart",
			Handler:    _Vpn_CouldStart_Handler,
		},
		{
			MethodName: "CheckServerAlive",
			Handler:    _Vpn_CheckServerAlive_Handler,
		},
		{
			MethodName: "StartCloakClient",
			Handler:    _Vpn_StartCloakClient_Handler,
		},
		{
			MethodName: "StopCloakClient",
			Handler:    _Vpn_StopCloakClient_Handler,
		},
		{
			MethodName: "InitLogger",
			Handler:    _Vpn_InitLogger_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vpnserver.proto",
}
